
# 动态规划

动态规划，无非就是利用历史记录，来避免我们的重复计算。 而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。

动态规划的三大步骤:

1. 定义数组元素的含义
    - 上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？
2. 找出数组元素之间的关系式
    - 有一点类似于归纳法。 
    - 也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，
    - 例如 dp[n] = dp[n-1] + dp[n-2] , 等等
    - 最难，最关键的一步
3. 找出初始值
    - dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，就是所谓的**初始值**. 
    - 很多时候，初始值 在第二步做归纳的时候，就顺便求出了

有了初始值, 并且有了数组元素之间的关系式, 就能计算出 dp[n], 问题就得到解决了。

动态规划通常采用以下两种方式中的一种:
1. 自顶向下
    - 将问题划分为若干子问题，求解这些子问题并保存结果以免重复计算。
    - 该方法将递归和缓存结合在一起
2. 自下而上
    - 先行求解所有可能用到的子问题，然后用其构造更大问题的解。


# 案例

## 1. 简单的一维 DP

问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

1. 定义数组元素的含义
    - 定义 dp[i] 的含义为：**跳上一个 i 级的台阶总共有 dp[i] 种跳法**. 
2. 找出数组元素间的关系式
    - 可知，青蛙到达第 n 级的台阶有两种方式 
        1. 从 第n-1阶 跳上来
        2. 从 第n-2阶 跳上来
    - dp[n] = dp[n-1] + dp[n-2] 
3. 找出初始条件
    - dp[0] = 0
    - dp[1] = 1
    - dp[2] = 2


```python
def memoize(f):
    memo = {}
    def helper(x):
        if x not in memo:
            memo[x] = f(x)
        return memo[x]
    return helper

@memoize
def steps( n ):
    if n <= 2 :
        return n
    return steps(n-1) + steps(n-2)

print steps(50)  # 20365011074
```

```python
def steps2(n) :
    if n < 2 :
        return n 

    dp = [0]* (n+1)
    # caution: you must initialize dp[0-3] 
    # if you use bottom-top solution
    dp[0] = 0
    dp[1] = 1
    dp[2] = 2
    for i in xrange( 3, n+1 , 1 ) : 
        dp[i] = dp[i-1] + dp[i-2]

    return dp[n]

print steps2(50) # 20365011074
```


## 2. 二维数组的 DP

问题描述: 

- 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。
- 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角.
- 问总共有多少条不同的路径？





